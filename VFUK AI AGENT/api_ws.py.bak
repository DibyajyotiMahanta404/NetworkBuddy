
import os
import sys
import re
import json
import time
import asyncio
import contextlib
from typing import Any, Dict, Optional, List

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Body
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# -------------------- Config (override via .env or environment) --------------------
MAIN_SCRIPT_PATH = os.getenv("MAIN_SCRIPT_PATH", "main.py")      # path to orchestrator script
PYTHON_BIN       = os.getenv("PYTHON_BIN", sys.executable)       # interpreter to use
WORKING_DIR      = os.getenv("WORKING_DIR", None)                # defaults to folder of main.py
MAIN_ARGS        = [a for a in os.getenv("MAIN_ARGS", "").split(",") if a.strip()]  # extra args
EXEC_TIMEOUT_SEC = int(os.getenv("EXEC_TIMEOUT_SEC", "900"))     # 15 min default
MAX_CAPTURE_BYTES = int(os.getenv("MAX_CAPTURE_BYTES", str(10_000_000)))  # 10 MB

# Optional: wait for a prompt regex in stdout before sending the user input.
# Your main.py prints: "ðŸ“¥ Enter your OSS request:" â€” emoji can vary, so leave blank by default.
WAIT_FOR_PROMPT_REGEX = os.getenv("WAIT_FOR_PROMPT_REGEX", "")
WAIT_PROMPT_TIMEOUT_SEC = float(os.getenv("WAIT_PROMPT_TIMEOUT_SEC", "2.0"))

app = FastAPI(title="OSS Agent CLI-compatible API", version="2.2")



# --- CORS configuration ---
# Allows the frontend at localhost:8080 (and others) to call this API from the browser
# Configure via env vars:
#   CORS_ALLOW_ORIGINS="http://localhost:8080,http://127.0.0.1:8080"
#   CORS_ALLOW_CREDENTIALS="true|false"
#   CORS_ALLOW_METHODS="*" or comma-separated, e.g. "GET,POST,OPTIONS"
#   CORS_ALLOW_HEADERS="*" or comma-separated

def _parse_bool(val: str, default: bool=False) -> bool:
    if val is None:
        return default
    return val.strip().lower() in ("1", "true", "yes", "on")

CORS_ALLOW_ORIGINS = [o.strip() for o in os.getenv("CORS_ALLOW_ORIGINS",
                          os.getenv("CORS_ALLOW_ORIGIN", "http://localhost:8080")).split(',') if o.strip()]
CORS_ALLOW_CREDENTIALS = _parse_bool(os.getenv("CORS_ALLOW_CREDENTIALS", "true"), True)
CORS_ALLOW_METHODS = [m.strip().upper() for m in os.getenv("CORS_ALLOW_METHODS", "*").split(',') if m.strip()]
CORS_ALLOW_HEADERS = [h.strip() for h in os.getenv("CORS_ALLOW_HEADERS", "*").split(',') if h.strip()]

app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS_ALLOW_ORIGINS if CORS_ALLOW_ORIGINS != ["*"] or not CORS_ALLOW_CREDENTIALS else ["http://localhost:8080"],
    allow_credentials=CORS_ALLOW_CREDENTIALS,
    allow_methods=CORS_ALLOW_METHODS if CORS_ALLOW_METHODS != ["*"] else ["*"],
    allow_headers=CORS_ALLOW_HEADERS if CORS_ALLOW_HEADERS != ["*"] else ["*"],
)
# --- end CORS configuration ---
# -------------------- Helpers --------------------
def _script_abspath() -> str:
    p = os.path.abspath(MAIN_SCRIPT_PATH)
    if not os.path.isfile(p):
        raise FileNotFoundError(f"MAIN_SCRIPT_PATH does not exist: {p}")
    return p

def _working_dir() -> Optional[str]:
    if WORKING_DIR:
        return WORKING_DIR
    try:
        return os.path.dirname(_script_abspath()) or None
    except Exception:
        return None

async def _read_stream_lines(stream: asyncio.StreamReader, source: str, on_line):
    """
    Read lines from a stream and feed them to on_line(source, text_line).
    The callback may be async or sync.
    """
    while True:
        line = await stream.readline()
        if not line:
            break
        text = line.decode("utf-8", errors="replace").rstrip("\n")
        await on_line(source, text)

async def _run_main_once(
    user_input: str,
    wait_prompt_regex: Optional[str] = WAIT_FOR_PROMPT_REGEX,
    timeout_sec: int = EXEC_TIMEOUT_SEC,
) -> Dict[str, Any]:
    """
    Run main.py once as a subprocess; capture stdout/stderr and a combined chronological log.
    We send the user's input, then close stdin (write_eof/close) so main.py exits after one cycle.
    """
    script_path = _script_abspath()
    cwd = _working_dir()
    args = [PYTHON_BIN, script_path] + MAIN_ARGS

    # Force UTF-8 in the child process so emojis/logs don't crash on Windows cp1252.
    child_env = os.environ.copy()
    child_env.setdefault("PYTHONUTF8", "1")
    child_env.setdefault("PYTHONIOENCODING", "utf-8")

    start_ts = time.time()
    proc = await asyncio.create_subprocess_exec(
        *args,
        cwd=cwd or None,
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        env=child_env,
    )

    stdout_lines: List[str] = []
    stderr_lines: List[str] = []
    combined: List[Dict[str, Any]] = []
    captured_bytes = 0

    prompt_event = asyncio.Event()
    prompt_re = re.compile(wait_prompt_regex) if wait_prompt_regex else None

    async def on_line(source: str, text: str):
        nonlocal captured_bytes
        enc = (text + "\n").encode("utf-8", errors="replace")
        if captured_bytes + len(enc) <= MAX_CAPTURE_BYTES:
            if source == "stdout":
                stdout_lines.append(text)
            else:
                stderr_lines.append(text)
            combined.append({"ts": time.time(), "source": source, "line": text})
            captured_bytes += len(enc)
        if source == "stdout" and prompt_re and prompt_re.search(text):
            prompt_event.set()

    # start readers
    t_out = asyncio.create_task(_read_stream_lines(proc.stdout, "stdout", on_line))
    t_err = asyncio.create_task(_read_stream_lines(proc.stderr, "stderr", on_line))

    # send prompt (after prompt appears, if configured)
    async def _send_input():
        try:
            if prompt_re:
                with contextlib.suppress(asyncio.TimeoutError):
                    await asyncio.wait_for(prompt_event.wait(), timeout=WAIT_PROMPT_TIMEOUT_SEC)
            if proc.stdin:
                proc.stdin.write((user_input + "\n").encode("utf-8", errors="replace"))
                await proc.stdin.drain()
                # Close stdin so next input() in main.py gets EOF and exits REPL cleanly
                with contextlib.suppress(Exception):
                    proc.stdin.write_eof()
                with contextlib.suppress(Exception):
                    proc.stdin.close()
        except Exception:
            pass

    t_in = asyncio.create_task(_send_input())

    # wait for process to finish (or timeout)
    try:
        await asyncio.wait_for(proc.wait(), timeout=timeout_sec)
    except asyncio.TimeoutError:
        with contextlib.suppress(ProcessLookupError):
            proc.kill()

    await asyncio.gather(t_out, t_err, t_in, return_exceptions=True)
    duration_ms = int((time.time() - start_ts) * 1000)

    return {
        "exit_code": getattr(proc, "returncode", -1),
        "timed_out": False if getattr(proc, "returncode", None) is not None else True,
        "duration_ms": duration_ms,
        "stdout_lines": stdout_lines,
        "stderr_lines": stderr_lines,
        "combined_log": combined,   # chronological list of {ts, source, line}
    }

# -------------------- Endpoints --------------------

@app.get("/healthz")
async def health():
    ok = True
    err = None
    try:
        _ = _script_abspath()
    except Exception as e:
        ok = False
        err = str(e)
    return {
        "ok": ok,
        "version": app.version,
        "main_path": os.path.abspath(MAIN_SCRIPT_PATH),
        "error": err,
    }

@app.post("/run")
async def run_once(
    body: Dict[str, Any] = Body(..., example={"session_id":"web_session","user_input":"Show alarms for ENodeB-1023"})
):
    """
    One-shot: run main.py once and return ALL output (stdout, stderr, combined log).
    """
    user_input = (body.get("user_input") or "").strip()
    if not user_input:
        return JSONResponse(status_code=400, content={"error": "user_input is required"})

    res = await _run_main_once(user_input=user_input)
    # convenience joins
    res["stdout"] = "\n".join(res["stdout_lines"])
    res["stderr"] = "\n".join(res["stderr_lines"])
    return JSONResponse(content=res)

@app.websocket("/ws/cli")
@app.websocket("/ws/chat")  # alias for your tester
async def ws_chat(ws: WebSocket):
    """
    WebSocket:
      Client -> {"session_id":"web_session","user_input":"..."}
      Server -> many {"event":"log","source":"stdout|stderr","line":"..."}
                then  {"event":"final","payload":{"result":"<entire stdout transcript>", "exit_code":..., ...}}
    """
    await ws.accept()
    try:
        init = await ws.receive_text()
        try:
            req = json.loads(init)
        except Exception:
            await ws.send_text(json.dumps({"event": "error", "message": "Invalid JSON"}))
            await ws.close()
            return

        user_input = (req.get("user_input") or "").strip()
        if not user_input:
            await ws.send_text(json.dumps({"event": "error", "message": "user_input is required"}))
            await ws.close()
            return

        # spawn main.py
        script_path = _script_abspath()
        cwd = _working_dir()
        args = [PYTHON_BIN, script_path] + MAIN_ARGS

        # Force UTF-8 in the child process
        child_env = os.environ.copy()
        child_env.setdefault("PYTHONUTF8", "1")
        child_env.setdefault("PYTHONIOENCODING", "utf-8")

        proc = await asyncio.create_subprocess_exec(
            *args,
            cwd=cwd or None,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=child_env,
        )

        # buffers to also produce a final transcript
        stdout_buf: List[str] = []
        stderr_buf: List[str] = []
        captured = 0

        prompt_re = re.compile(WAIT_FOR_PROMPT_REGEX) if WAIT_FOR_PROMPT_REGEX else None
        prompt_event = asyncio.Event()

        async def on_line(source: str, text: str):
            nonlocal captured
            # stream to client as soon as we see a line
            try:
                await ws.send_text(json.dumps({"event": "log", "source": source, "line": text}))
            except Exception:
                pass
            enc = (text + "\n").encode("utf-8", errors="replace")
            if captured + len(enc) <= MAX_CAPTURE_BYTES:
                if source == "stdout":
                    stdout_buf.append(text)
                else:
                    stderr_buf.append(text)
                captured += len(enc)
            if source == "stdout" and prompt_re and prompt_re.search(text):
                prompt_event.set()

        async def read_stream(stream: asyncio.StreamReader, source: str):
            while True:
                line = await stream.readline()
                if not line:
                    break
                text = line.decode("utf-8", errors="replace").rstrip("\n")
                await on_line(source, text)

        t_out = asyncio.create_task(read_stream(proc.stdout, "stdout"))
        t_err = asyncio.create_task(read_stream(proc.stderr, "stderr"))
        start_ts = time.time()

        async def send_input():
            try:
                if prompt_re:
                    with contextlib.suppress(asyncio.TimeoutError):
                        await asyncio.wait_for(prompt_event.wait(), timeout=WAIT_PROMPT_TIMEOUT_SEC)
                if proc.stdin:
                    proc.stdin.write((user_input + "\n").encode("utf-8", errors="replace"))
                    await proc.stdin.drain()
                    # Close stdin so REPL exits after printing the result
                    with contextlib.suppress(Exception):
                        proc.stdin.write_eof()
                    with contextlib.suppress(Exception):
                        proc.stdin.close()
            except Exception:
                pass

        t_in = asyncio.create_task(send_input())

        try:
            await asyncio.wait_for(proc.wait(), timeout=EXEC_TIMEOUT_SEC)
        except asyncio.TimeoutError:
            with contextlib.suppress(ProcessLookupError):
                proc.kill()

        await asyncio.gather(t_out, t_err, t_in, return_exceptions=True)
        duration_ms = int((time.time() - start_ts) * 1000)

        # Final message compatible with "final-only" testers that print payload.result
        final_payload = {
            "result": "\n".join(stdout_buf) or "(no stdout)",
            "exit_code": getattr(proc, "returncode", -1),
            "duration_ms": duration_ms,
            "timed_out": (getattr(proc, "returncode", None) is None),
            "stderr_preview": "\n".join(stderr_buf[-20:]) if stderr_buf else "",
        }
        await ws.send_text(json.dumps({"event": "final", "payload": final_payload}))
    except WebSocketDisconnect:
        return
    except Exception as e:
        with contextlib.suppress(Exception):
            await ws.send_text(json.dumps({"event": "error", "message": str(e)}))
    finally:
        with contextlib.suppress(Exception):
            await ws.close()

@app.get("/")
def root():
    return {
        "service": app.title,
        "version": app.version,
        "endpoints": {
            "ws_stream": "/ws/chat (or /ws/cli)",
            "run_once": "POST /run",
            "health": "GET /healthz",
        },
        "config": {
            "MAIN_SCRIPT_PATH": os.path.abspath(MAIN_SCRIPT_PATH),
            "PYTHON_BIN": PYTHON_BIN,
            "WORKING_DIR": _working_dir(),
            "MAIN_ARGS": MAIN_ARGS,
            "EXEC_TIMEOUT_SEC": EXEC_TIMEOUT_SEC,
            "WAIT_FOR_PROMPT_REGEX": WAIT_FOR_PROMPT_REGEX,
            "WAIT_PROMPT_TIMEOUT_SEC": WAIT_PROMPT_TIMEOUT_SEC,
        },
    }

if __name__ == "__main__":
    # Start on port 8000 (matches your tester)
    uvicorn.run("api_ws:app", host="0.0.0.0", port=int(os.getenv("PORT", "8000")), reload=False)
